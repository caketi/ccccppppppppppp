# 系统设计 服务+

scenario场景-设计哪些功能 DAU/QPS/Features/Interfaces 
service服务-大系统拆分为小服务 split/application/module
storage存储-数据如何存储和访问 schema/data/sql/nosql/file system
scale升级-解决缺陷，处理可能遇到的问题 sharding

## Storage

- database - 是文件系统的一层包装，db依赖于fs
- file system -- 图片、视频media files
- cache -- 不支持数据持久化nonpersistent

## SOA(service oriented architecture)

## pull model vs. push model[fanout]

facebook-pull
twitter-pull
instagram - push+pull

- pull算法
 用户查看NewsFeed时，获取每个好友的前100条tweets，合并出前100条News Feed
   k路归并算法 Merge k sorted Arrays
- pull复杂度分析
 NewsFeed 假如有n个关注对象，n次db reads的时间+k路鬼并购时间（可忽略，在内存中执行）--为什么
 post a tweet 1次db write的时间

```python
  getNewsFeed(request)
   followings = DB.getFollowings(user=request.user)
   news_feed = empty
   for follow in followings:
     tweets = DB.getTweets(follow.to_user, 100) # n次db reads非常慢且发生在用户获得Feed的请求过程中
     news_feed.merge(tweets)
   sort(news_feed)
   return news_feed[:100]
postTweet(reuqest, tweet)
 DB.insertTweet(request.user, tweet)
 return success 
```

- push算法

为每个用户建一个list存储他的News Feed信息
用户发一个tweet后，将该推文逐个推送到每个用户的News Feed List中
 fanout
用户需要查看News Feed时，只需要从该News Feed List中读取最新的100条即可

- push复杂度分析
 News Feed 1次db read
 post a tweet n个粉丝，n次db writes
   可使用一步任务后台执行，无需用户等待

```python
getNewsFeed(request)
 return DB.getNewsFeed(request.user)

postTweet(reuqest, tweet_info)
 tweet = DB.insertTweet(request.user, tweet_info)
 AsyncService.fanoutTweet(request.user, tweet)
 return success 
AsyncService::fanoutTweet(user, tweet)
 followers = DB.getFollowers(user)
 for follower in followers:
   DB.insertNewsFeed(tweet, follower)

```

## scale

- Optimize

- maintance